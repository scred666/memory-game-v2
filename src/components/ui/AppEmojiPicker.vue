<template>
  <transition name="win">
    <WinMessage v-if="isGameWin" @replay="replay" />
  </transition>

  <ReplayButton :disabled="isEmpty(solvedItems)" class="aep-ReplayButton" @click="replay">
    Restart ðŸŽ²
  </ReplayButton>
  <div :style="{ '--color': `var(${currentDifficult.color})` }" class="aep-Picker">
    <AppEmojiItem
      v-for="item in normalizedEmojiList"
      :key="item[PUBLIC_ID]"
      v-model="selectedItems"
      :is-disabled="isDisabled({ item })"
      :is-solved="solvedItems.includes(item[PRIVATE_ID])"
      :item="item"
    />
  </div>
</template>

<script lang="ts" setup>
import { isEmpty } from 'lodash-es'
import { computed, type ComputedRef, type PropType, ref, watch } from 'vue'

import AppEmojiItem from '@/components/ui/AppEmojiItem.vue'
import ReplayButton from '@/components/ui/ReplayButton.vue'
import WinMessage from '@/components/ui/WinMessage.vue'
import { type Difficult, DIFFICULTY_KEYS } from '@/utils/difficult-switcher'
import { EMOJI_ITEM_KEYS, EMOJI_LIST, type EmojiItem } from '@/utils/emoji'
import { shuffleArray, TIMEOUT_DELAY } from '@/utils/helpers'
import { uid } from '@/utils/uid'

defineOptions({
  name: 'AppEmojiPicker'
})

const props = defineProps({
  currentDifficult: {
    type: Object as PropType<Difficult>,
    required: true
  }
})

const { PUBLIC_ID, PRIVATE_ID } = EMOJI_ITEM_KEYS

const emojiList = ref<string[]>([...EMOJI_LIST])

const listByDifficult = computed(() => {
  return shuffleArray(emojiList.value).slice(0, props.currentDifficult[DIFFICULTY_KEYS.COUNT])
}) as ComputedRef<string[]>

const normalizedEmojiList = computed(() => {
  const enrichedList = listByDifficult.value.flatMap(emoji => {
    const privateId = uid()
    const item = {
      emoji,
      [PRIVATE_ID]: privateId
    }

    return [
      {
        ...item,
        [PUBLIC_ID]: uid()
      },
      {
        ...item,
        [PUBLIC_ID]: uid()
      }
    ]
  })

  return shuffleArray(enrichedList)
}) as ComputedRef<EmojiItem[]>

const isReplayStarted = ref<boolean>(false)

const replay = (): void => {
  resetState()
  isReplayStarted.value = true
  setTimeout(() => {
    isReplayStarted.value = false
    emojiList.value = shuffleArray(emojiList.value)
  }, TIMEOUT_DELAY)
}

const selectedItems = ref<string[]>([])

const isSelectionComplete = computed(() => {
  return selectedItems.value.length === 2
}) as ComputedRef<boolean>

const isDisabled = ({ item }: { item: EmojiItem }): boolean => {
  return (
    isReplayStarted.value ||
    isSelectionComplete.value ||
    selectedItems.value.includes(item[PUBLIC_ID]) ||
    solvedItems.value.includes(item[PRIVATE_ID])
  )
}

const solvedItems = ref<string[]>([])

const isGameWin = computed(() => {
  return solvedItems.value.length === listByDifficult.value.length
}) as ComputedRef<boolean>

watch(selectedItems, () => {
  if (isSelectionComplete.value) {
    const [first, second] = selectedItems.value

    const originalFirst = normalizedEmojiList.value.find(
      item => item[PUBLIC_ID] === first
    ) as EmojiItem

    const originalSecond = normalizedEmojiList.value.find(
      item => item[PUBLIC_ID] === second
    ) as EmojiItem

    if (originalFirst[PRIVATE_ID] === originalSecond[PRIVATE_ID]) {
      solvedItems.value = [...solvedItems.value, originalFirst[PRIVATE_ID]]
      selectedItems.value = []
    } else {
      setTimeout(() => {
        selectedItems.value = []
      }, TIMEOUT_DELAY)
    }
  }
})

const resetState = (): void => {
  selectedItems.value = []
  solvedItems.value = []
}

watch(
  () => props.currentDifficult,
  () => {
    resetState()
  }
)
</script>

<style lang="scss" scoped>
.aep-Picker {
  justify-content: center;
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
}

.win-enter-active,
.win-leave-active {
  transition: 0.2s;
}

.win-enter-from,
.win-leave-to {
  opacity: 0;
  transform: scale(1.15);
}

.aep-ReplayButton {
  margin-inline: auto;
  --padding: 10px 16px 10px 20px;
}
</style>
